# 第1章 総復習：Python入門

## 📚 この章の学習目標

**ディープラーニング実装に必要なPythonの基礎スキルを習得する**

```
Python基礎
    ↓
NumPy（数値計算）
    ↓
Matplotlib（可視化）
    ↓
ディープラーニングの実装基盤
```

---

## 1. NumPy - 数値計算の基盤

### 1.1 NumPyとは

**NumPy**は、Pythonで高速な数値計算を行うためのライブラリです。

#### なぜ必要？

```
┌────────────────────────────────────┐
│ Pythonの標準リスト                  │
│   ↓                                │
│ 数値計算が遅い                      │
│   ↓                                │
│ NumPy（C言語で実装）               │
│   ↓                                │
│ 高速な数値計算                      │
│   ↓                                │
│ ディープラーニングの計算は          │
│ 行列演算が中心                      │
└────────────────────────────────────┘
```

### 1.2 NumPy配列の作成

```python
import numpy as np

# 配列の作成
x = np.array([1, 2, 3])
print(type(x))  # <class 'numpy.ndarray'>

# ndarray = N-dimensional array（N次元配列）
```

**基本的な配列操作：**
```python
# 1次元配列
x = np.array([1, 2, 3])
print(x.shape)  # (3,)
print(x.ndim)   # 1（1次元）

# 配列の要素にアクセス
print(x[0])     # 1
print(x[1])     # 2
```

---

### 1.3 算術演算（要素ごと）⭐

```python
x = np.array([1, 2, 3])
y = np.array([4, 5, 6])

print(x + y)  # [5 7 9]   ← 要素ごとの加算
print(x - y)  # [-3 -3 -3]
print(x * y)  # [4 10 18] ← 要素ごとの乗算
print(x / y)  # [0.25 0.4 0.5]
```

**視覚的理解：**
```
x + y の計算：
  [1, 2, 3]
+ [4, 5, 6]
-----------
  [5, 7, 9]  ← 各要素を対応する位置で計算
```

**重要ポイント：**
- NumPyの演算は**要素ごと（element-wise）**
- ループを書く必要がない（ベクトル化）
- 高速に計算できる

---

### 1.4 N次元配列

#### 2次元配列（行列）

```python
# 2次元配列（行列）
A = np.array([[1, 2, 3], 
              [4, 5, 6]])

print(A.shape)  # (2, 3) → 2行3列
print(A.ndim)   # 2 → 2次元
print(A.dtype)  # int32 or int64（データ型）
```

**形状（shape）の意味：**
```
shape = (2, 3)
         ↑  ↑
         行 列

  列0 列1 列2
行0 [ 1   2   3 ]
行1 [ 4   5   6 ]
```

#### 配列のインデックス

```python
A = np.array([[1, 2, 3], 
              [4, 5, 6]])

print(A[0])      # [1 2 3]（0行目）
print(A[0][2])   # 3
print(A[0, 2])   # 3（推奨される書き方）

# スライス
print(A[:, 1])   # [2 5]（全行の1列目）
```

---

### 1.5 ブロードキャスト ⭐⭐⭐

**異なる形状の配列同士を自動的に拡張して計算**

#### 基本例

```python
A = np.array([[1, 2], 
              [3, 4]])
B = np.array([10, 20])

print(A * B)
# [[10 40]
#  [30 80]]
```

**何が起こっている？**
```
A.shape = (2, 2)
B.shape = (2,)

NumPyが自動でBを拡張：
B = [10, 20]
  ↓ ブロードキャスト
B = [[10, 20],  ← 各行に複製
     [10, 20]]

計算：
  [[1  2]     [[10 20]     [[10 40]
   [3  4]]  ×  [10 20]]  =  [30 80]]
```

#### ブロードキャストのルール

```
形状の確認：
(3, 4) と (4,)   → OK  (3, 4)に拡張
(3, 4) と (3, 1) → OK  (3, 4)に拡張
(3, 4) と (3,)   → NG  形状が合わない
```

**ブロードキャストの重要性：**
1. ループ不要で効率的
2. コードが簡潔
3. メモリ効率が良い
4. ディープラーニングで頻繁に使用

#### 実践例

```python
# バイアスの追加（ディープラーニングで頻出）
X = np.array([[1, 2], 
              [3, 4], 
              [5, 6]])  # (3, 2)
b = np.array([10, 20])  # (2,)

print(X + b)
# [[11 22]
#  [13 24]
#  [15 26]]

# bが各行に自動的に追加される
```

---

### 1.6 NumPyの便利な関数

```python
# 配列の生成
np.zeros((2, 3))     # 0で初期化
np.ones((2, 3))      # 1で初期化
np.arange(0, 10, 2)  # [0, 2, 4, 6, 8]
np.linspace(0, 1, 5) # [0, 0.25, 0.5, 0.75, 1]

# 数学関数
x = np.array([1, 2, 3])
np.exp(x)    # [e^1, e^2, e^3]
np.sqrt(x)   # [√1, √2, √3]
np.sin(x)    # [sin(1), sin(2), sin(3)]

# 統計関数
np.sum(x)    # 合計
np.mean(x)   # 平均
np.max(x)    # 最大値
np.min(x)    # 最小値
```

---

## 2. Matplotlib - データ可視化

### 2.1 基本的なグラフ描画

```python
import numpy as np
import matplotlib.pyplot as plt

# データの準備
x = np.arange(0, 6, 0.1)  # 0から6まで0.1刻み
y = np.sin(x)

# グラフの描画
plt.plot(x, y)
plt.xlabel('x')
plt.ylabel('y')
plt.title('sin function')
plt.show()
```

**グラフのイメージ：**
```
y ↑
1 │    ╱╲     ╱╲
  │   ╱  ╲   ╱  ╲
0 │──╱────╲─╱────╲─→ x
  │       ╲╱      ╲╱
-1│
```

---

### 2.2 複数のグラフを描画

```python
import numpy as np
import matplotlib.pyplot as plt

x = np.arange(0, 6, 0.1)
y1 = np.sin(x)
y2 = np.cos(x)

# 複数のグラフを描画
plt.plot(x, y1, label='sin')
plt.plot(x, y2, linestyle='--', label='cos')
plt.xlabel('x')
plt.ylabel('y')
plt.title('sin & cos')
plt.legend()  # 凡例を表示
plt.show()
```

**スタイル指定：**
```python
# 線のスタイル
plt.plot(x, y, linestyle='-')   # 実線
plt.plot(x, y, linestyle='--')  # 破線
plt.plot(x, y, linestyle='-.')  # 一点鎖線

# 色の指定
plt.plot(x, y, color='red')
plt.plot(x, y, color='b')       # 青

# マーカー
plt.plot(x, y, marker='o')      # 丸
plt.plot(x, y, marker='x')      # バツ
```

---

### 2.3 画像の表示

```python
from PIL import Image
import numpy as np

# 画像の読み込み
img = Image.open('sample.png')

# NumPy配列に変換
img_array = np.array(img)
print(img_array.shape)  # (高さ, 幅, チャンネル数)

# 画像の表示
plt.imshow(img)
plt.axis('off')  # 軸を非表示
plt.show()
```

**画像データの構造：**
```
RGB画像の場合：
shape = (高さ, 幅, 3)
                    ↑
              R, G, Bチャンネル

グレースケールの場合：
shape = (高さ, 幅)
```

---

## 3. Pythonの基礎（復習）

### 3.1 クラス

```python
class Person:
    def __init__(self, name, age):
        self.name = name  # インスタンス変数
        self.age = age
    
    def greet(self):  # メソッド
        print(f"こんにちは、{self.name}です")

# インスタンスの作成
person = Person("太郎", 20)
person.greet()  # こんにちは、太郎です
```

**クラスの構成要素：**
```
┌────────────────────────────┐
│ クラス                      │
├────────────────────────────┤
│ __init__: コンストラクタ   │
│ self: インスタンス自身      │
│ メソッド: インスタンスの操作│
└────────────────────────────┘
```

---

## 第1章のキーポイント

```
┌─────────────────────────────────────┐
│ NumPyの重要概念                      │
├─────────────────────────────────────┤
│ ✓ ndarray（N次元配列）              │
│ ✓ 要素ごとの演算                    │
│ ✓ 形状（shape）の理解               │
│ ✓ ブロードキャスト ⭐⭐⭐           │
│ ✓ ベクトル化（ループ不要の高速計算）│
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│ Matplotlibの重要概念                 │
├─────────────────────────────────────┤
│ ✓ グラフの描画                      │
│ ✓ 複数グラフの重ね描き              │
│ ✓ 画像の表示                        │
│ ✓ データの可視化                    │
└─────────────────────────────────────┘
```

---

## 復習問題

### Q1: NumPy配列の基本

以下のコードの出力を答えよ：

```python
import numpy as np
x = np.array([1, 2, 3, 4])
y = np.array([5, 6, 7, 8])
print(x * y)
```

<details>
<summary>答えを見る</summary>

**答え:**
```python
[5 12 21 32]
```

**解説:**
NumPyの演算は要素ごと（element-wise）に行われる：
```
x = [1, 2, 3, 4]
y = [5, 6, 7, 8]
  ↓ 要素ごとの乗算
x*y = [1×5, 2×6, 3×7, 4×8]
    = [5, 12, 21, 32]
```

</details>

---

### Q2: ブロードキャスト

以下のコードの出力を答えよ：

```python
import numpy as np
A = np.array([[1, 2], [3, 4]])
B = np.array([10, 20])
print(A * B)
```

<details>
<summary>答えを見る</summary>

**答え:**
```python
[[10 40]
 [30 80]]
```

**解説:**
ブロードキャストにより、Bが各行に拡張される：
```
A.shape = (2, 2)
B.shape = (2,)

Bが自動的に拡張：
B = [10, 20]
  ↓ ブロードキャスト
B = [[10, 20],
     [10, 20]]

計算：
A * B = [[1×10, 2×20],
         [3×10, 4×20]]
      = [[10, 40],
         [30, 80]]
```

**ポイント:**
- ブロードキャストにより、形状が自動的に調整される
- メモリ効率が良い（実際にはコピーされない）
- ディープラーニングで頻繁に使用される

</details>

---

### Q3: 配列の形状

以下のコードの各配列の形状（shape）を答えよ：

```python
import numpy as np
x = np.array([1, 2, 3])
A = np.array([[1, 2], [3, 4], [5, 6]])
B = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
```

<details>
<summary>答えを見る</summary>

**答え:**
```python
x.shape  # (3,)     ← 1次元配列（要素数3）
A.shape  # (3, 2)   ← 2次元配列（3行2列）
B.shape  # (2, 2, 2) ← 3次元配列
```

**解説:**

**x: 1次元配列**
```
[1, 2, 3]
 ↑  ↑  ↑
 要素数3 → shape = (3,)
```

**A: 2次元配列**
```
  列0 列1
行0 [1, 2]
行1 [3, 4]
行2 [5, 6]

3行2列 → shape = (3, 2)
```

**B: 3次元配列**
```
B[0] = [[1, 2],    B[1] = [[5, 6],
        [3, 4]]            [7, 8]]

2つの2×2行列 → shape = (2, 2, 2)
               (ブロック数, 行数, 列数)
```

</details>

---

### Q4: NumPy関数の活用

以下のような処理を実装せよ：
- 0から10まで0.5刻みの配列を作成
- その配列の各要素の2乗を計算
- 結果をグラフで表示

<details>
<summary>答えを見る</summary>

**答え:**
```python
import numpy as np
import matplotlib.pyplot as plt

# 0から10まで0.5刻みの配列
x = np.arange(0, 10.5, 0.5)

# 各要素の2乗
y = x ** 2  # または np.power(x, 2)

# グラフ表示
plt.plot(x, y)
plt.xlabel('x')
plt.ylabel('y = x²')
plt.title('Square Function')
plt.grid(True)
plt.show()

print(f"x.shape = {x.shape}")  # (21,)
print(f"y.shape = {y.shape}")  # (21,)
```

**ポイント:**
- `np.arange(start, stop, step)`で等間隔の配列を生成
- `**`演算子で累乗計算（要素ごと）
- NumPyの演算は自動的にベクトル化される

</details>

---

### Q5: ブロードキャストの応用

ニューラルネットワークでよく使われる以下の処理を実装せよ：
- 3×2の行列Xを作成
- 1×2のバイアスベクトルbを作成
- X + b を計算（各行にbが加算される）

<details>
<summary>答えを見る</summary>

**答え:**
```python
import numpy as np

# 3×2の行列
X = np.array([[1, 2],
              [3, 4],
              [5, 6]])

# 1×2のバイアス
b = np.array([10, 20])

# ブロードキャストによる加算
result = X + b

print(result)
# [[11 22]
#  [13 24]
#  [15 26]]
```

**解説:**
```
X.shape = (3, 2)
b.shape = (2,)

ブロードキャスト：
b = [10, 20]
  ↓
b = [[10, 20],
     [10, 20],
     [10, 20]]

X + b = [[1+10, 2+20],
         [3+10, 4+20],
         [5+10, 6+20]]
      = [[11, 22],
         [13, 24],
         [15, 26]]
```

**ディープラーニングでの使用例:**
```python
# 線形変換: y = Wx + b
# W: 重み行列, x: 入力, b: バイアス
y = np.dot(x, W) + b  # bが各行に自動的に加算
```

</details>

---

## 学習チェックリスト

第1章の理解度を確認しましょう：

### NumPy
- [ ] NumPy配列（ndarray）を作成できる
- [ ] 配列の形状（shape）を理解している
- [ ] 要素ごとの演算ができる
- [ ] ブロードキャストの概念を理解している
- [ ] ブロードキャストを使った計算ができる
- [ ] NumPyの数学関数を使える
- [ ] 多次元配列のインデックスアクセスができる

### Matplotlib
- [ ] 基本的なグラフを描画できる
- [ ] 複数のグラフを重ね描きできる
- [ ] グラフのスタイルを変更できる
- [ ] 画像を表示できる

### Python基礎
- [ ] クラスの定義と使用ができる
- [ ] インスタンス変数とメソッドを理解している

---

## 次章への準備

### 第2章で学ぶこと

**パーセプトロン - ニューラルネットワークの起源**

```
第1章で習得したNumPy
    ↓
第2章: パーセプトロンの実装
    ↓
重みとバイアスの概念
    ↓
論理回路の実装
    ↓
多層化の必要性
```

**第1章の知識がどう活かされるか：**
- NumPy配列 → 入力・重み・バイアスの表現
- 要素ごとの演算 → 加重和の計算
- ブロードキャスト → バイアスの追加
- Matplotlib → 結果の可視化

---

## まとめ

### 第1章で習得したスキル

```
┌────────────────────────────────────┐
│ ディープラーニングの実装基盤       │
├────────────────────────────────────┤
│ NumPy                              │
│  ├─ 高速な数値計算                 │
│  ├─ 配列演算                       │
│  └─ ブロードキャスト               │
│                                    │
│ Matplotlib                         │
│  ├─ データの可視化                 │
│  ├─ 学習曲線の表示                 │
│  └─ 結果の分析                     │
└────────────────────────────────────┘
```

### 重要な概念

1. **ベクトル化**
   - ループを書かずに配列全体を一度に計算
   - 高速・簡潔なコード

2. **ブロードキャスト**
   - 形状の異なる配列同士の演算
   - メモリ効率が良い

3. **可視化**
   - データの理解を深める
   - 学習の進行状況を監視

**これらのスキルがディープラーニング実装の土台となります！**

次章では、これらのツールを使ってパーセプトロンを実装します 🚀
